// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol)

pragma solidity ^0.8.0;

import "./token/ERC721Upgradeable.sol";

import "./access/AccessControlEnumerableUpgradeable.sol";
import "./utils/ContextUpgradeable.sol";
import "./utils/CountersUpgradeable.sol";
import "./utils/Initializable.sol";
import "./security/PausableUpgradeable.sol";

/**
 * @dev {ERC721} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *  - token ID and URI autogeneration
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter and pauser
 * roles, as well as the default admin role, which will let it grant both minter
 * and pauser roles to other accounts.
 *
 * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._
 */
contract WhyNotWorldGameNFT is
    Initializable,
    ContextUpgradeable,
    AccessControlEnumerableUpgradeable,
    ERC721Upgradeable,
    PausableUpgradeable
{
    function initialize(
        string memory name,
        string memory symbol,
        string memory baseTokenURI
    ) public virtual initializer {
        __WhyNotWorldGameNFT_init(name, symbol, baseTokenURI);
    }

    using CountersUpgradeable for CountersUpgradeable.Counter;

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

    CountersUpgradeable.Counter private _tokenIdTracker;

    string private _baseTokenURI;

    using StringsUpgradeable for uint256;

    // Optional mapping for token URIs
    mapping(uint256 => string) private _tokenURIs;

    enum Scene {
        None,
        Scene1,
        Scene2,
        Scene3,
        Scene4,
        Scene5,
        Scene6,
        Scene7,
        Scene8,
        Scene9
    }
    enum Algo {
        None,
        WinWin,
        WinFwd,
        WinLion,
        WinPartner,
        Limited
    }

    struct Token {
        bool isReserved;
        bool isRefunded;
        bool isSold;
        uint256 refundByTokenId;
        uint256 tokenId;
        Algo buyAlgo;
        Scene parentScene;
        uint256 parentTokenIndex;
        bool isReservedForDiscount;
    }

    //Scene to Token Array, Which NFT is associated with Which Scene
    mapping(Scene => mapping(uint256 => Token)) sceneTokens;
    mapping(Scene => uint256) public sceneTokenCount;
    mapping(Scene => uint256) public sceneSoldCount;

    //To Avoid loop to find which token is eligible for 2/3 refund, we have created
    // array as per scene and pop the last element. if this is empty,
    // which means there is no token in previous scene which deserve 2/3 refund.
    // When someone would purchase, he would get immediate refund.
    mapping(Scene => uint256[]) tokenIndexToRefund;

    //When someone want to purchase a token other than scene 1,
    // first find out is there any reserved slot which has not sold yet. If there is such slot
    // pick that first and update it otherwise create new Token object.
    // To manage that we used this array
    mapping(Scene => uint256[]) tokenIndexToBuy;

    mapping(uint256 => uint256) public tokenIdCopyCake;

    //Store token which are sold first and later someone buy previous scene token so they
    // just need to be marked reserved and refund immediate
    mapping(Scene => uint256[]) tokenIndexSoldButNotReserved;

    struct Payout {
        uint256 tokenId;
        Scene scene;
        uint256 fromTokenId;
        Scene fromScene;
        uint256 payoutIndex;
    }

    Payout[] payoutData;

    uint256 payoutReturnIndex = 0;

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    function __WhyNotWorldGameNFT_init(
        string memory name,
        string memory symbol,
        string memory baseTokenURI
    ) internal onlyInitializing {
        __ERC721_init(name, symbol);
        __AccessControlEnumerable_init();
        __Pausable_init();
        __WhyNotWorldGameNFT_init_unchained(name, symbol, baseTokenURI);
    }

    function __WhyNotWorldGameNFT_init_unchained(
        string memory,
        string memory,
        string memory baseTokenURI
    ) internal onlyInitializing {
        _baseTokenURI = baseTokenURI;

        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

        _setupRole(MINTER_ROLE, _msgSender());
        _setupRole(PAUSER_ROLE, _msgSender());
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @dev update base URI of token metadata to new `_baseTokenURI`
     *
     * Requirements:
     *
     * - The caller must have the `Admin Role`
     */
    function setBaseURI(string memory baseTokenURI)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        _baseTokenURI = baseTokenURI;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(
            _exists(tokenId),
            "ERC721URIStorage: URI query for nonexistent token"
        );

        string memory _tokenURI = _tokenURIs[tokenId];
        string memory base = _baseURI();

        // If there is no base URI, return the token URI.
        if (bytes(base).length == 0) {
            return _tokenURI;
        }
        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).
        if (bytes(_tokenURI).length > 0) {
            return string(abi.encodePacked(base, _tokenURI));
        }

        return super.tokenURI(tokenId);
    }

    /**
     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _setTokenURI(uint256 tokenId, string memory _tokenURI)
        internal
        virtual
    {
        require(
            _exists(tokenId),
            "ERC721URIStorage: URI set of nonexistent token"
        );
        _tokenURIs[tokenId] = _tokenURI;
    }

    /**
     * @dev See {ERC721-_burn}. This override additionally checks to see if a
     * token-specific URI was set for the token, and if so, it deletes the token URI from
     * the storage mapping.
     */
    function _burn(uint256 tokenId) internal virtual override {
        super._burn(tokenId);

        if (bytes(_tokenURIs[tokenId]).length != 0) {
            delete _tokenURIs[tokenId];
        }
    }

    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual onlyRole(PAUSER_ROLE) {
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override whenNotPaused {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(AccessControlEnumerableUpgradeable, ERC721Upgradeable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    function safeMintNFT(address to_, string memory tokenURI_)
        internal
        returns (uint256)
    {
        uint256 tokenId = _tokenIdTracker.current();
        _safeMint(to_, tokenId);
        _setTokenURI(tokenId, tokenURI_);

        _tokenIdTracker.increment();
        return tokenId;
    }

    function safeMintNFTs(address to_, string[] memory tokenURIs_)
        internal
        returns (uint256[] memory)
    {
        uint256[] memory tokenIds = new uint256[](tokenURIs_.length);
        for (uint256 i = 0; i < tokenURIs_.length; i++) {
            tokenIds[i] = safeMintNFT(to_, tokenURIs_[i]);
        }
        return tokenIds;
    }

    function getMaxSceneWhichCanBeBought(Algo buyAlgo)
        internal
        pure
        returns (Scene)
    {
        return
            (buyAlgo == Algo.Limited) ? Scene.None : (buyAlgo == Algo.WinFwd)
                ? Scene.Scene8
                : (buyAlgo == Algo.WinLion)
                ? Scene.Scene7
                : Scene.Scene9;
    }

    function getNextSceneCountWhichCanBeReserved(Algo buyAlgo)
        internal
        pure
        returns (uint8)
    {
        return
            (buyAlgo == Algo.Limited) ? 0 : (buyAlgo == Algo.WinFwd)
                ? 2
                : (buyAlgo == Algo.WinLion)
                ? 3
                : 1;
    }

    /**
     * WinWin Method where you buy 1 NFT from a scene and it reserve slot in next scene
     * when you purchase, it refund 2/3 amount to previous scene for this which scene was reserved.
     */
    function safeMintAlgo(
        address to_,
        string[] memory tokenURIs_,
        Scene[] memory scenes_,
        Algo buyAlgo_
    ) public virtual whenNotPaused onlyRole(MINTER_ROLE) {
        require(buyAlgo_ > Algo.None, "Invalid Algo");

        uint8 arrLength = (buyAlgo_ == Algo.WinWin ||
            buyAlgo_ == Algo.WinPartner)
            ? 1
            : (buyAlgo_ == Algo.WinFwd)
            ? 2
            : (buyAlgo_ == Algo.WinLion)
            ? 3
            : 9;

        require(tokenURIs_.length == arrLength, "Invalid Tokens Passed");
        require(scenes_.length == arrLength, "Invalid Scenes passed");

        require(scenes_[0] > Scene.None, "Invalid Scene");
        require(sceneSoldCount[scenes_[0]] < 120, "Scene already has 120 NFT");

        Scene nextScene = scenes_[0];
        //Scene nextNextScene;
        for (uint256 i = 1; i < scenes_.length; i++) {
            //nextNextScene = _scenes[i];
            require(
                (uint256(nextScene) + 1) == uint256(scenes_[i]),
                "Invalid Scene Sequence Passed"
            );
            require(
                sceneSoldCount[scenes_[i]] < 120,
                "One of scene in Scene sequence already sold"
            );
            nextScene = scenes_[i];
        }

        if (buyAlgo_ == Algo.WinPartner) {
            require(
                sceneTokenCount[Scene(uint256(scenes_[0]) + 1)] < 120,
                "No Next slot available to reserve for WinPartner."
            );
        }

        uint256[] memory tokenIds = safeMintNFTs(to_, tokenURIs_);
        Payout memory payout;
        //Scene currentScene = scenes_[0];

        //Find Token Either reserved which is not sold or create newer one.
        Token memory currentToken;
        uint256 currentTokenIndex = sceneTokenCount[scenes_[0]];
        if (tokenIndexToBuy[scenes_[0]].length > 0) {
            //currentTokenIndex = tokenIndexToBuy[scenes_[0]].length - 1;
            currentTokenIndex = tokenIndexToBuy[scenes_[0]][
                tokenIndexToBuy[scenes_[0]].length - 1
            ];

            currentToken = sceneTokens[scenes_[0]][currentTokenIndex];
            currentToken.tokenId = tokenIds[0];
            currentToken.isSold = true;
            currentToken.buyAlgo = buyAlgo_;

            tokenIndexToBuy[scenes_[0]].pop();
        } else {
            currentToken = Token(
                false,
                false,
                true,
                0,
                tokenIds[0],
                buyAlgo_,
                Scene.None,
                0,
                false
            );
            sceneTokenCount[scenes_[0]] = currentTokenIndex + 1;
            tokenIndexSoldButNotReserved[scenes_[0]].push(currentTokenIndex);
        }

        if (scenes_[0] < getMaxSceneWhichCanBeBought(buyAlgo_)) {
            Scene reserveScene = Scene(
                uint256(scenes_[0]) +
                    getNextSceneCountWhichCanBeReserved(buyAlgo_)
            );

            //Check if there is already a token for next Scene which is sold be not reserved.
            // if so, mark it reseved and refund current token immediately.
            if (
                tokenIndexSoldButNotReserved[reserveScene].length > 0 &&
                buyAlgo_ != Algo.WinPartner
            ) {
                uint256 soldIndex = tokenIndexSoldButNotReserved[reserveScene][
                    tokenIndexSoldButNotReserved[reserveScene].length - 1
                ];
                sceneTokens[reserveScene][soldIndex].isReserved = true;
                currentToken.isRefunded = true;
                currentToken.refundByTokenId = sceneTokens[reserveScene][
                    soldIndex
                ].tokenId;
                tokenIndexSoldButNotReserved[reserveScene].pop();

                payout = Payout(
                    currentToken.tokenId,
                    scenes_[0],
                    currentToken.refundByTokenId,
                    reserveScene,
                    payoutData.length
                );
                payoutData.push(payout);
            } else {
                //Reserve Next Token for Current Token
                sceneTokens[reserveScene][
                    sceneTokenCount[reserveScene]
                ] = Token(
                    true,
                    false,
                    false,
                    0,
                    0,
                    Algo.None,
                    Scene.None,
                    0,
                    (buyAlgo_ == Algo.WinPartner ? true : false)
                );

                tokenIndexToBuy[reserveScene].push(
                    sceneTokenCount[reserveScene]
                );
                sceneTokenCount[reserveScene] =
                    sceneTokenCount[reserveScene] +
                    1;
                if (buyAlgo_ != Algo.WinPartner) {
                    if (scenes_.length > 1) {
                        tokenIndexToRefund[scenes_[scenes_.length - 1]].push(
                            sceneTokenCount[scenes_[scenes_.length - 1]]
                        );
                    } else {
                        tokenIndexToRefund[scenes_[scenes_.length - 1]].push(
                            sceneTokenCount[scenes_[scenes_.length - 1]] - 1
                        );
                    }
                }
            }
        }

        //Refund Previous scene buyer.
        if (scenes_[0] > Scene.Scene1) {
            Scene previousScene = Scene(uint256(scenes_[0]) - 1);
            if (tokenIndexToRefund[previousScene].length > 0) {
                uint256 refundIndex = tokenIndexToRefund[previousScene][
                    tokenIndexToRefund[previousScene].length - 1
                ];

                if (
                    sceneTokens[previousScene][refundIndex].buyAlgo ==
                    Algo.WinWin
                ) {
                    sceneTokens[previousScene][refundIndex].isRefunded = true;
                    sceneTokens[previousScene][refundIndex]
                        .refundByTokenId = tokenIds[0];
                    payout = Payout(
                        sceneTokens[previousScene][refundIndex].tokenId,
                        previousScene,
                        tokenIds[0],
                        scenes_[0],
                        payoutData.length
                    );
                } else {
                    Token memory childToken = sceneTokens[previousScene][
                        refundIndex
                    ];
                    sceneTokens[childToken.parentScene][
                        childToken.parentTokenIndex
                    ].isRefunded = true;
                    sceneTokens[childToken.parentScene][
                        childToken.parentTokenIndex
                    ].refundByTokenId = tokenIds[0];
                    payout = Payout(
                        sceneTokens[childToken.parentScene][
                            childToken.parentTokenIndex
                        ].tokenId,
                        childToken.parentScene,
                        tokenIds[0],
                        scenes_[0],
                        payoutData.length
                    );
                }
                payoutData.push(payout);
                tokenIndexToRefund[previousScene].pop();
            }
        }

        sceneTokens[scenes_[0]][currentTokenIndex] = currentToken;
        sceneSoldCount[scenes_[0]] = sceneSoldCount[scenes_[0]] + 1;

        uint256 copyCake = 3**(uint256(scenes_[0]) - 1);

        for (uint256 i = 1; i < scenes_.length; i++) {
            //Create new Token for next scene and mark it sold and reserved.
            sceneTokens[scenes_[i]][sceneTokenCount[scenes_[i]]] = Token(
                true,
                false,
                true,
                0,
                tokenIds[i],
                buyAlgo_,
                scenes_[0],
                currentTokenIndex,
                false
            );
            sceneSoldCount[scenes_[i]] = sceneSoldCount[scenes_[i]] + 1;
            sceneTokenCount[scenes_[i]] = sceneTokenCount[scenes_[i]] + 1;
            copyCake += 3**(uint256(scenes_[i]) - 1);
        }

        tokenIdCopyCake[tokenIds[0]] = copyCake;
    }

    function getSceneTokenData(uint256 tokenId, Scene scene)
        public
        view
        returns (
            address owner_,
            Algo buyAlgo,
            Scene nextReservedScene
        )
    {
        require(scene > Scene.None, "Invalid Scene");
        require(sceneTokenCount[scene] > 0, "Scene NFT not exist");

        uint256 searchIndex = binarySearch(
            0,
            sceneTokenCount[scene],
            tokenId,
            scene
        );
        require(searchIndex < 121, "TokenId not exist for scene");

        Token memory tokenData = sceneTokens[scene][searchIndex];
        buyAlgo = tokenData.buyAlgo;
        require(buyAlgo > Algo.None, "TokenId not exist for scene");

        owner_ = ownerOf(tokenId);

        nextReservedScene = Scene.None;
        //1/2/3 via winLion : for 3 and 2 parent would be 1, for 1 parent would be none, for 1 it should 1 + 3 = 4,
        //for 2nd & 3rd also would  1 + 3 ( for 1st getting request than will use scene1 for it)
        if (buyAlgo != Algo.Limited) {
            Scene parentScene = tokenData.parentScene == Scene.None
                ? scene
                : tokenData.parentScene;
            nextReservedScene = Scene(
                uint256(parentScene) +
                    getNextSceneCountWhichCanBeReserved(buyAlgo)
            );
        }
    }

    function binarySearch(
        uint256 startIndex,
        uint256 endIndex,
        uint256 tokenId,
        Scene scene
    ) private view returns (uint256 tokenIndex) {
        if (endIndex >= startIndex) {
            uint256 midIndex = startIndex + (endIndex - startIndex) / 2;

            // If the element is present at the middle itself
            Token memory tokenData = sceneTokens[scene][midIndex];
            if (tokenData.tokenId == tokenId) {
                return midIndex;
            }

            // If element is smaller than mid, then it can only be present in left subarray
            if (tokenData.tokenId > tokenId) {
                return binarySearch(startIndex, midIndex - 1, tokenId, scene);
            }

            // Else the element can only be present in right subarray
            return binarySearch(midIndex + 1, endIndex, tokenId, scene);
        }

        // when element is not present in array, retuning index 121 as -1 not valid for uint
        return 121;
    }

    function getAvailableReservedTokenForScene(Scene scene)
        external
        view
        returns (Token memory)
    {
        require(scene > Scene.None, "Invalid Scene");
        require(
            tokenIndexToBuy[scene].length > 0,
            "No Reserved Token for Scene"
        );
        uint256 currentTokenIndex = sceneTokenCount[scene];
        Token memory currentToken;
        if (tokenIndexToBuy[scene].length > 0) {
            currentTokenIndex = tokenIndexToBuy[scene][
                tokenIndexToBuy[scene].length - 1
            ];
            currentToken = sceneTokens[scene][currentTokenIndex];
        }
        return currentToken;
    }

    function getPayoutData()
        public
        view
        returns (
            uint256 tokenId,
            Scene scene,
            uint256 fromTokenId,
            Scene fromScene,
            uint256 payoutIndex,
            address tokenIdOwner
        )
    {
        // payoutArray data size = 2, when index 1 deleted, payoutReturnIndex = 2, payoutLength = 2, out of bound
        require(
            payoutData.length > 0 && payoutReturnIndex < payoutData.length,
            "No data for payout processing"
        );

        //need valiation here payoutReturnIndex data alreday deleted.
        //returninig 0/1/2/3 etc index data, after delete returnIndex increased, so 0 / 1/2 etc fetched
        Payout memory payout = payoutData[payoutReturnIndex];
        return (
            payout.tokenId,
            payout.scene,
            payout.fromTokenId,
            payout.fromScene,
            payout.payoutIndex,
            ownerOf(payout.tokenId)
        );
    }

    function deletePayoutData(uint256 indexToDelete)
        public
        onlyRole(MINTER_ROLE)
    {
        Payout memory payout = payoutData[indexToDelete];
        require(payout.scene > Scene.None, "Index data already deleted");

        payoutReturnIndex = indexToDelete + 1;
        //here deleting all index data which are return by get method only
        delete payoutData[indexToDelete];
    }

    /**
     * Owner is needed by opensea for openzeppelin upgradeable smart contract
     */
    function owner() public view virtual returns (address) {
        return getRoleMember(DEFAULT_ADMIN_ROLE, 0);
    }

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[100] private __gap;
}
